{"id":"node_modules/tone/build/esm/core/worklet/SingleIOProcessor.worklet.js","dependencies":[{"name":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js.map","includedInParent":true,"mtime":1734481789361},{"name":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\Tone\\core\\worklet\\SingleIOProcessor.worklet.ts","includedInParent":true,"mtime":1734481791457},{"name":"B:\\moichim\\Downloads\\jppC5aAS\\package.json","includedInParent":true,"mtime":1734481796391},{"name":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\package.json","includedInParent":true,"mtime":1734481788755},{"name":"./ToneAudioWorkletProcessor.worklet.js","loc":{"line":1,"column":7,"index":7},"parent":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js","resolved":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\build\\esm\\core\\worklet\\ToneAudioWorkletProcessor.worklet.js"},{"name":"./WorkletGlobalScope.js","loc":{"line":2,"column":29,"index":78},"parent":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\build\\esm\\core\\worklet\\SingleIOProcessor.worklet.js","resolved":"B:\\moichim\\Downloads\\jppC5aAS\\node_modules\\tone\\build\\esm\\core\\worklet\\WorkletGlobalScope.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.singleIOProcess = void 0;\nrequire(\"./ToneAudioWorkletProcessor.worklet.js\");\nvar _WorkletGlobalScope = require(\"./WorkletGlobalScope.js\");\nconst singleIOProcess = exports.singleIOProcess = /* javascript */`\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n(0, _WorkletGlobalScope.addToWorklet)(singleIOProcess);"},"sourceMaps":{"js":{"mappings":[{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":7,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":7,"column":7}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":8,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":8,"column":4}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":8,"column":23}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":8,"column":26}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":2,"column":0},"generated":{"line":8,"column":33}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":7},"generated":{"line":9,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":13},"generated":{"line":9,"column":6}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":28},"generated":{"line":9,"column":21}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":28},"generated":{"line":9,"column":24}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":28},"generated":{"line":9,"column":31}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":28},"generated":{"line":9,"column":32}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":28},"generated":{"line":9,"column":47}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":31},"generated":{"line":9,"column":50}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":4,"column":48},"generated":{"line":9,"column":66}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":71,"column":1},"generated":{"line":76,"column":1}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":77,"column":0}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":0},"generated":{"line":77,"column":4}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":12},"generated":{"line":77,"column":36}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":13},"generated":{"line":77,"column":38}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":28},"generated":{"line":77,"column":53}},{"source":"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts","name":null,"original":{"line":73,"column":29},"generated":{"line":77,"column":54}}],"sources":{"../../../../Tone/core/worklet/SingleIOProcessor.worklet.ts":"import \"./ToneAudioWorkletProcessor.worklet.js\";\nimport { addToWorklet } from \"./WorkletGlobalScope.js\";\n\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n\naddToWorklet(singleIOProcess);\n"},"lineCount":null}},"error":null,"hash":"6f2fcfb830c5cf4cbfcc9dd8454fd6c8","cacheData":{"env":{}}}